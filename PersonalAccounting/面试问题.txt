多线程的join()与sleep的区别？
答：
特性	                       t.join()	                   Thread.sleep(long)
等待对象	等待目标线程 t 执行完毕	    等待指定时间，和其他线程无关
线程状态	当前线程进入WAITING状态	    当前线程进入TIMED_WAITING状态
锁释放	释放持有的对象锁（如果有）	不释放任何锁
sleep()：“定时休眠，锁不放，和他人无关”；
join()：“依赖等待，锁释放，等目标线程完”。

共享资源不需要同步的情况有哪些？
答：
基本数据类型赋值（long和double除外）
引用类型赋值
不可变对象
局部变量


String与StringBuilder与StringBuffer区别在哪？
答：
可变性：String 不可变，StringBuilder 可变；
性能：String 拼接创建新对象，性能低；StringBuilder 原地修改，性能高；
线程安全：String 天然安全，StringBuilder 线程不安全；
场景：固定字符串用 String，单线程大量拼接用 StringBuilder，多线程拼接用 StringBuffer。
若需多线程安全的可变字符串，可使用 StringBuffer（StringBuilder 的线程安全版本，所有修改方法都加了 synchronized，但性能略低于 StringBuilder）。

int与Integer区别在那？
答：int是基本数据类型；Integer是引用类型，是int的包装类。所有的包装类型都是不变类。因此，一旦创建了Integer对象，该对象就是不变的。
对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较。
Byte/Short/Integer/Long/Character/Boolean 有缓存，Float/Double 无缓存；Integer 缓存默认范围 -128~127，上限可通过 JVM 参数配置，下限固定；Integer 不是都有缓存：仅 valueOf()（自动装箱）使用缓存，new Integer() 不使用；

谈谈对枚举类的了解
答：枚举类内部的每个枚举项都是该枚举类的单例实例。
枚举类（enum）是 Java 中专门用于表示固定且有限个常量的特殊类（如季节、星期、状态码），相比普通常量定义更安全、可读性更强。
枚举类默认继承 java.lang.Enum，不能继承其他类，但可实现接口，其内部每个枚举项都是该枚举类的单例实例。
枚举天然支持多线程安全，可用于实现单例模式，还能包含属性、方法和构造方法（构造方法默认私有，无法外部实例化）。enum的构造方法要声明为private，字段强烈建议声明为final；
支持 switch 语句匹配，提供 values()（获取所有枚举项）、valueOf()（通过名称获取枚举项）等便捷方法，避免了普通常量的类型错误风险。


1. HashMap和LinkedHashMap
答：HashMap：Java 中最常用的哈希表实现，基于「数组 + 链表 / 红黑树」实现，用于存储「键值对（Key-Value）」，核心特点是无序存储（存储顺序与插入顺序、访问顺序无关），查询、插入、删除效率较高（平均时间复杂度 O (1)），允许 Key/Value 为 null（Key 仅允许一个 null，Value 允许多个 null），非线程安全。高效无额外开销，适合无需关注存储顺序的场景。
LinkedHashMap：继承自 HashMap，底层在 HashMap 基础上增加了「双向链表」，用于维护键值对的顺序，核心特点是有序存储，既保留了 HashMap 的高效查询特性，又解决了其无序的问题，同样非线程安全。

2. java虚拟机的内存分区？哪些是线程私有的 哪些是共享的?
3. java虚拟机内存回收策略
4. synchornized和 votaile区别？synchronized实现原理
5. java线程池，运行原理
6. 进程和线程区别,进程之间通信方式
TCP UDP区别，TCP为什么要三次握手 四次挥手?不能少一次吗?
7. HTTP和HTTPS区别？http get post put 区别？
8. 快速排序思想，时间复杂度，最坏多少？什么情况最坏?稳定吗?
手撕：实现字符串中第一个只出现一次的字符。


activity的生命周期 7次
activity的启动模式 4次

安卓线程间通信方式（handler）6次
答：Handler 是 Android 中线程间通信的核心机制，主要解决子线程无法更新 UI 的问题，也支持任意线程间的消息传递。其底层基于 Thread + Looper + MessageQueue + Message 四大组件的协同工作，本质是消息驱动的异步通信模型。
Handler：消息的发送者和处理者
Message：线程间传递的消息载体
MessageQueue：消息队列，负责存储 Handler 发送的消息，单链表实现，插入删除效率高。
Looper：消息队列的轮询器，负责循环取出消息。Looper 只负责取出消息并转发给消息自身的Message.target成员变量的值Handler，不关心其他Handler实例，保证了消息的精准分发。

在主线程中， Looper 和 MessageQueue是不是只能有一个，而Handler可以拥有多个，那如果Handler可以拥有多个，那有什么作用呢？
答：L和MQ只能有一个，而Handler可以拥有多个。消息分类隔离：按业务 / 功能拆分消息；独立的消息优先级 / 调度策略：实现差异化消息处理。每个 Handler 可以发送不同特性的消息（延迟消息、重复消息、即时消息）。

为什么子线程中能直接 new Handler 吗？为什么？
答：不能，因为子线程没有Looper。只有主线程才会自动创建Looper。子线程可以通过Looper.prepare()创建。

如果子线程没有创建Looper是不是就只能发送不能接受主线程发送的消息？
答：是的。

Handler 为什么会导致内存泄漏？怎么解决？
答：原因：非静态内部类的 Handler 会默认持有外部类（如 Activity）的强引用；若 Handler 发送的是延迟消息，会导致 Activity 即使关闭也无法被 GC 回收，引发内存泄漏。
解决方法：
① 定义 静态内部类 Handler + 弱引用 WeakReference 持有外部类；
② Activity 销毁时，调用 handler.removeCallbacksAndMessages(null) 移除所有未处理的消息。

Handler线程是如何切换的？
（1）假设现在有一个线程A，在A线程中通过Looper.prepare和Looper.loop来开启Looper,并且在A线程中实例化出来一个Handler。Looper.prepare()方法被调用时会为会初始化Looper并为ThreadLocal 设置Looper，此时ThreadLocal中就存储了A线程的Looper。另外MessageQueue也会在Looper中被初始化。
（2）接着当调用Loop.loop方法时，loop方法会通过myLooper得到A线程中的Looper，进而拿到Looper中的MessageQueue，接着开启死循环等待执行MessageQueue中的方法。
（3）此时，再开启一个线程B，并在B线程中通过Handler发送出一个Message，这个Message最终会通过sendMessageAtTime方法调用到MessageQueue的equeueMessage方法将消息插入到队列。
（4）由于Looper的loop是一个死循环，当MessageQueue中被插入消息的时候，loop方法就会取出MessageQueue中的消息，并执行callback。而此时，Looper是A线程的Looper,进而调用的Message或者Handler的Callback都是执行在A线成中的。以此达到了线程的切换。

主线程为什么不用初始化Looper？
答：因为应用在启动的过程中就已经初始化主线程Looper了。

能不能让一个Message加急被处理？/ 什么是Handler同步屏障？
答：能。实现 Message 加急处理的核心方案是使用 Handler 同步屏障（Synchronous Barrier），通过插入同步屏障，让系统优先处理「异步 Message」，从而实现消息的加急执行（普通 Message 会被暂时阻塞，直到屏障移除）。同步屏障是 MessageQueue 中的一种「特殊标记」（本质是一条 target = null 的 Message），它的核心作用是阻断普通同步 Message 的执行，让后续的异步 Message 优先被 Looper 取出并处理，实现消息的优先级调度。
底层逻辑：
同步屏障是 target = null 的特殊 Message，插入 MessageQueue 后，Looper.loop() 遍历队列时会识别该标记；
遇到同步屏障时，Looper 会跳过所有后续的同步 Message，只筛选出异步 Message 进行处理；
只有移除同步屏障后，Looper 才会恢复处理普通同步 Message。

Handler的阻塞唤醒机制是怎么回事？
答： Handler的阻塞唤醒机制是基于Linux的阻塞唤醒机制。
这个机制也是类似于handler机制的模式。在本地创建一个文件描述符，然后需要等待的一方则监听这个文件描述符，唤醒的一方只需要修改这个文件，那么等待的一方就会收到文件从而打破唤醒。和Looper监听MessageQueue，Handler添加message是比较类似的。


安卓进程间通信方式（binder）5次
（1）Binder是什么？
答：Binder 是 Android 系统特有的跨进程通信（IPC）核心机制。Binder 通信依赖 4 个角色的协同。
Client（客户端）：发起跨进程请求的进程（如普通 App 进程），持有服务端的 Binder 代理对象。
Server（服务端）：处理请求并返回结果的进程（如 system_server 系统服务进程），持有 Binder 实体对象。
Binder 驱动：核心中间层（内核态），负责转发请求 / 响应，实现数据的一次内存拷贝，是通信的核心桥梁。
ServiceManager：系统服务的「注册表」，管理所有服务端的 Binder 实体，提供服务查询功能（客户端通过它获取目标服务的代理对象）。
（2）Android 为什么选择 Binder 作为核心 IPC 机制？
标准答案：
性能更优：仅需 1 次内存拷贝，相比 Socket 的 2 次拷贝效率更高，兼顾了轻量级通信的需求；
安全性更高：Binder 自带 UID/PID 身份验证，由系统底层保障，避免了恶意进程的非法调用，而 Socket 等需要手动实现验证逻辑；
易用性更强：Android 封装了 AIDL、Messenger 等上层 API，开发者无需关注底层驱动和序列化细节，降低了跨进程通信的开发成本；
契合 Android 架构：完美支撑四大组件、系统服务的跨进程调用，适配 Android 的组件化和沙箱模型。
（3）Binder 通信的一次内存拷贝是如何实现的？
标准答案：
传统 Socket 通信：客户端数据 → 内核缓冲区（第 1 次拷贝）→ 服务端缓冲区（第 2 次拷贝），存在两次拷贝；
Binder 通信：Binder 驱动在内核态创建一块「共享内存区域」，客户端直接将数据写入该共享内存（无需拷贝到内核缓冲区），服务端从该共享内存直接读取数据，仅在「客户端写入共享内存」时发生 1 次拷贝，大幅提升效率。
（4）Binder 有哪两种常用的上层实现方式？区别是什么？
标准答案：
两种实现方式分别是 Messenger 和 AIDL，核心区别如下：
Messenger：
轻量级封装，无需编写 AIDL 文件，开发成本低；
基于 Handler 机制，串行处理消息，不支持高并发；
仅支持发送 Message 类型数据，适合简单的消息交互场景（如单向通信、双向简单消息回复）。
AIDL：
需编写 .aidl 接口文件，系统自动生成 Binder 代理类，开发成本稍高；
支持多方法调用、批量数据传输，可通过线程池处理并发请求，效率更高；
支持 Parcelable 自定义对象、List/Map 等，适合复杂场景（如系统服务、跨进程数据交互）。


view的绘制流程 4次
触摸事件的传递 4次
	
下面只问过一次的，很多是从上面的高频问题中引申出来的：
activityA启动后打开activityB，两个activity的状态经历了哪些周期？
可以在子线程里面刷新UI吗？如果我非要在子线程里刷新了UI呢？会怎么样？会抛出什么异常？
答：不可以。因为ui控件不是线程安全。非要在子线程刷新 UI，大概率会抛出 CalledFromWrongThreadException 异常；少数情况可能出现 UI 显示错乱、卡顿甚至崩溃，无统一稳定表现。

ANR是什么？ANR产生的根本原因是什么？多久会出现这个异常？所有的情况都是 5s 吗？Service里面也是5s吗？
答：ANR 是 Application Not Responding 的缩写，即应用无响应，是 Android 系统检测到应用长时间无法响应用户输入或系统事件时，弹出的提示框，告知用户当前应用已卡死。ANR 本质是主线程阻塞，无法及时响应关键事件；
触发时间并非统一 5s：Activity 前台输入是 5s，广播是 10s/60s，Service 是 20s/200s；Service 场景的 ANR 阈值远大于 5s，和 Activity 场景的触发条件、时间均不同。

application的oncreate和activity的oncreate有什么区别?

Ibinder了解吗？

一个点击事件点击结束后是怎么被销毁的？

looper的睡眠机制对应linux的哪个操作？
答：Looper 的睡眠 / 阻塞机制，底层依赖 Linux 的epoll（I/O 多路复用）机制，具体到 Native 层核心调用是epoll_wait()，而承载这一操作的安卓 Native 层方法是nativePollOnce()。

looper最多能开几个线程？
答：一个线程只能有一个looper，在整个引用中带 Looper 的线程数量无明确上限，受系统资源限制。

handler的一个postDelay()方法知道吗？
答：将一个Runnable任务投递到消息队列中，并指定一个延迟时间（毫秒级），等待延迟时间到达后，再由 Looper 取出任务并执行。postDelay() 并没有让线程睡眠，而是将Runnable封装为Message，并为Message设置「唤醒时间」，然后将Message入队，直到到达唤醒时间，Looper 才会取出该Message并执行。

如果创建了两个handler，如何知道哪个消息对应哪个handler？
答：Message.target存储的是Handler实例，所有Message.target就能确定消息对应哪个handler。

上下滑动事件和左右滑动事件的冲突如何处理？

recyclerView了解吗？它是如何复用视图的？

activity和fragment之间是如何进行通信的？


1.同步和异步
2.串行和并行
3.并行和并发
4.TCP三次握手，两次有什么问题？
5.HTTPS加密流程，为什么既有对称加密又有非对称加密？
6.OSI七层网络模型，各层的协议
7.进程之间如何通信？
8.TCP和UDP的区别
9.TCP还有哪些机制保证可靠性？
手撕
1.简单单表查询SQL
2.力扣3原题
3.力扣1143原题

安卓UI问题
介绍一下`ListView`和`RecyclerView`的区别
答：
`ListView` 和 `RecyclerView` 都是 Android 中用于展示大量数据列表的 UI 组件，其中 `RecyclerView` 是 `ListView` 的升级版，在功能、灵活性、性能上都更具优势，二者的核心区别可从以下几个维度清晰区分：

### 一、 布局灵活性：`RecyclerView` 支持多种布局，`ListView` 功能单一
1.  **`ListView`**：仅支持**线性布局**（垂直排列，横向需额外改造），布局形式固定，无法直接实现网格、瀑布流等复杂列表效果，扩展性极差。
2.  **`RecyclerView`**：通过「布局管理器（`LayoutManager`）」实现多种布局，灵活度拉满，官方提供 3 种默认布局管理器，还支持自定义：
    - `LinearLayoutManager`：线性布局（对应 `ListView` 的功能），支持垂直/横向排列；
    - `GridLayoutManager`：网格布局（对应 `GridView` 的功能），如相册列表；
    - `StaggeredGridLayoutManager`：瀑布流布局，如电商商品列表、朋友圈图片列表。

### 二、 Item 复用与性能：`RecyclerView` 优化更彻底，性能更优
1.  **`ListView`**：
    - 具备基础的 Item 复用机制（通过 `convertView` 复用已滑出屏幕的 Item 视图），但需要**手动在 `getView()` 方法中实现**（判断 `convertView` 是否为 `null`，非空则复用）；
    - 若开发者未手动优化（忽略 `convertView` 复用），会频繁创建/销毁 Item 视图，导致内存溢出、滑动卡顿，优化成本高。
2.  **`RecyclerView`**：
    - 自带**更完善、更彻底的 Item 复用机制**（通过 `ViewHolder` 模式强制实现），无需开发者手动处理，从根源上避免了不当优化导致的性能问题；
    - 复用逻辑封装在底层，开发者只需实现 `ViewHolder` 持有 Item 中的控件引用，减少了 `findViewById()` 的频繁调用，进一步提升滑动流畅度，性能远优于 `ListView`。

### 三、 功能扩展性：`RecyclerView` 自带丰富功能，`ListView` 需手动实现
1.  **Item 动画**：
    - `ListView`：无自带 Item 动画，增、删、改 Item 时无过渡效果，若需动画，需手动自定义动画逻辑，开发成本高；
    - `RecyclerView`：自带 `ItemAnimator` 动画管理器，支持 Item 增、删、移动的默认过渡动画，也可自定义动画效果，实现简单且效果流畅。
2.  **多类型 Item**：
    - `ListView`：支持多类型 Item，但需要在 `getView()` 中手动判断 Item 类型、加载对应布局，逻辑繁琐，容易出错；
    - `RecyclerView`：通过重写 `getItemViewType()` 方法即可优雅实现多类型 Item，逻辑清晰，封装性更好，扩展性更强（如聊天界面的发送/接收消息布局、电商列表的商品/广告布局）。
3.  **滑动辅助功能**：
    - `ListView`：仅支持基础滑动，无自带的下拉刷新、上拉加载更多、侧滑删除等功能，需依赖第三方库实现；
    - `RecyclerView`：可配合 `ItemTouchHelper` 轻松实现侧滑删除、拖拽排序，配合 `SwipeRefreshLayout` 实现下拉刷新，上拉加载更多也更易封装，生态更完善。

### 四、 其他细节区别
1.  **点击事件处理**：
    - `ListView`：提供自带的 `OnItemClickListener`（条目点击）和 `OnItemLongClickListener`（条目长按），直接设置即可使用，简单便捷；
    - `RecyclerView`：无自带的条目点击/长按事件，需要开发者在 `ViewHolder` 中手动给 Item 根布局设置点击/长按监听，虽稍显繁琐，但灵活性更高（可实现 Item 内部单个控件的点击事件）。
2.  **数据更新**：
    - `ListView`：更新数据需调用 `notifyDataSetChanged()`，会刷新整个列表（无论数据是否局部变化），效率较低；
    - `RecyclerView`：提供多种局部刷新方法（如 `notifyItemChanged()`、`notifyItemInserted()`），仅刷新变化的 Item，无需刷新整个列表，性能更优。

### 总结（简洁易记，面试必备）
1.  布局灵活性：`ListView` 仅支持线性布局，`RecyclerView` 支持线性/网格/瀑布流，更灵活；
2.  性能与复用：`RecyclerView` 自带 `ViewHolder` 强制复用，性能优于 `ListView`（需手动优化复用）；
3.  功能扩展性：`RecyclerView` 自带 Item 动画、支持多类型 Item 和侧滑/拖拽，`ListView` 需手动实现；
4.  官方推荐：目前 Android 开发中，`RecyclerView` 已完全替代 `ListView` 和 `GridView`，是列表展示的首选组件。

Context是什么？
答：Context 是 Android 组件的运行环境，是组件与系统交互的桥梁；核心作用是访问资源、启动组件、获取系统服务；
有 Activity、Service、Application 三种常用形态，Application 是全局唯一上下文；

findViewById作用是什么？
答：findViewById() 的核心就是建立布局 xml 中的控件与 Java 代码中实例的关联。调用 findViewById() 前，必须先通过 setContentView()（Activity 中）或 LayoutInflater.inflate()（Fragment / 自定义 View 中）将布局文件加载到内存中，否则无法找到对应 View，返回 null。

为什么ViewBinding/DataBinding 替代 findViewById()？
答：ViewBinding/DataBinding 解决 findViewById() 的空指针、类型转换问题。
避免空指针异常（NullPointerException）：findViewById() 若查找的 ID 不存在、布局未加载或 ID 写错，会返回 null，后续操作该对象会直接崩溃；而 ViewBinding/DataBinding 编译时生成对应布局的绑定类，直接关联存在的控件，不存在空指针风险。
避免类型转换异常：findViewById() 返回 View 类型，需手动强转为具体控件（如 Button、EditText），类型写错会抛出 ClassCastException；而 ViewBinding/DataBinding 编译时已确定控件类型，直接获取即可，无需手动强转。

安卓常用的布局有哪些？各自的适用场景是什么？
答：LinearLayout（线性布局）：按水平 / 垂直方向排列组件，适合简单的线性布局（如导航栏、列表项）；
RelativeLayout（相对布局）：通过组件间相对位置排列，减少布局嵌套，适合复杂界面；
FrameLayout（帧布局）：组件堆叠显示，适合单一组件（如全屏图片）或需要叠加的场景（如图片 + 文字水印）；
ConstraintLayout（约束布局）：支持灵活的约束关系，可实现复杂界面且无嵌套，是官方推荐的主流布局（替代 RelativeLayout）；
RecyclerView（列表布局）：用于展示大量数据列表，复用 Item 视图，性能优于 ListView。

如何进行布局优化？
答：减少布局嵌套（避免多层嵌套导致测量 / 绘制耗时，优先用 ConstraintLayout）；
使用 <include> 标签复用通用布局（如标题栏、底部导航）；
使用 <merge> 标签消除多余父布局（配合 include 使用，减少布局层级）；
延迟加载非首屏布局（使用 ViewStub，需要时再 Inflate，减少初始化开销）。

什么是View？什么是ViewGroup？
答： 
对比维度	                        View	                                                       ViewGroup	
核心定位	所有可视化元素的顶级抽象父类（技术底层）	    View 的子类，容器型 UI 元素（承载管理其他 View）		
	
继承关系	 顶级父类，继承自 Object	                                        继承自 View
View 是「单个 UI 元素」，ViewGroup 是「装 UI 元素的盒子」

View 绘制流程是什么？
答：
Measure → Layout → Draw
测量（Measure）—— 确定 View 的「大小」（宽 / 高）
布局（Layout）—— 确定 View 的「位置」（上下左右坐标）
绘制（Draw）—— 把 View 「画到屏幕上」

当 View 的大小、位置、内容发生变化时，会触发重绘，常用方法：
requestMeasure()：触发重新测量（后续自动执行布局、绘制）；
requestLayout()：触发重新布局（后续自动执行绘制）；
invalidate()：触发重新绘制（跳过测量、布局，直接执行绘制，效率最高）
触发重绘时，优先使用invalidate()

绘制步骤	                                   普通 View（如 MoneyView）	                  ViewGroup（如 BillHorizontalLayout）
Measure	           仅测量自身，重写 onMeasure() 计算并保存自身宽高	      先测量所有子 View（measureChild()），再测量自身，汇总子 View 尺寸计算自身宽高
Layout	无需重写 onLayout()，使用父类默认实现，接收父 View 坐标	     必须重写 onLayout()，先确定自身位置，再遍历所有子 View 分配坐标（childView.layout()）
Draw	               必须重写 onDraw()，手动绘制自身内容（文本、图片等）	     无需重写 onDraw()，系统默认 dispatchDraw() 遍历绘制所有子 View，如需自身背景可重写

关键注意点（新手避坑）
普通 View 重写 onMeasure() 后，必须调用 setMeasuredDimension() 保存测量结果，否则测量无效；
ViewGroup 必须重写 generateLayoutParams()，指定支持的 LayoutParams，否则子 View 的 layout_width/layout_height 无效；
ViewGroup 测量子 View 时，可使用 measureChild()（单个子 View）或 measureChildren()（所有子 View），避免手动构建 MeasureSpec；
触发重绘时，优先使用 invalidate()（仅绘制），而非 requestLayout()（全流程），提升效率。


Android常见的存储方式
答：Android 有 5 种常见存储方式：内部存储、外部存储、SQLite、Room、SharedPreferences、网络存储
SQLite：存储结构化、复杂关联的数据，如用户信息列表、聊天记录、本地缓存的商品数据等。
SharedPreferences：支持存储的数据类型：String、Int、Boolean、Float、Long，不支持复杂对象存储
Room 是 Jetpack 官方 ORM 框架，封装了 SQLite，简化结构化数据存储操作；
核心 3 大组件：Entity（表映射）、Dao（数据操作）、Database（数据库入口）；

activity生命周期
答：
OnCreate: 一生一次，负责一次性全局初始化
OnStart:从不可见到可见
OnResume:从可见不可交互到可见可交互
OnPause:从可见可交互到可见不可交互，Activity可能是透明或未完全遮挡
OnStop:从可见不可交互到不可见不可交互
OnRestart:当处于"已停止"状态的 Activity 即将重启时，系统就会调用此回调。onRestart()会从Activity停止时的状态恢复Activity至运行状态。
OnDestroy:销毁activity

Activity主要的四种状态
答：
Running（运行）：在屏幕前台（位于当前任务堆栈的顶部）
Paused（暂停）：失去焦点但仍然对用户可见（覆盖Activity可能是透明或未完全遮挡）
Stopped（停止）：完全被另一个Activity覆盖
Destroyed（销毁）：退出，完全销毁。回收工作、资源释放

activity启动模式
答：
standard（标准模式）：默认模式，每次启动 Activity 都会创建新实例，入栈顶。
场景：大多数普通页面（如新闻详情、商品详情），无需复用实例的场景。
singleTop（栈顶复用）：若 Activity 已在栈顶，不创建新实例，调用onNewIntent()；否则创建新实例。
场景：通知栏点击打开的页面、搜索页面（避免栈顶重复创建）。
singleTask（栈内复用）：整个任务栈中只保留一个实例，若存在则将其上方 Activity 出栈并调用onNewIntent()，否则创建新实例。
场景：应用首页、主界面（保证整个应用只有一个首页实例，避免返回栈混乱）。
singleInstance（单实例模式）：Activity 独占一个任务栈，整个系统中只有一个实例，其他应用可通过该栈访问。
场景：系统级页面（如电话拨号界面、微信的语音通话页面），需全局唯一的场景。


Activity A 启动另一个Activity B 会调用哪些方法？如果B是透明主题的又或则是个DialogActivity呢 ？
答：
普通不透明 B：A.onPause() → B.onCreate()→B.onStart()→B.onResume() → A.onStop()（A 完全不可见，触发 onStop()）。
透明主题 / DialogActivity B：A.onPause() → B.onCreate()→B.onStart()→B.onResume()（A 部分 / 完全可见，不触发 onStop()）。
核心规律：是否触发 A 的 onStop()，取决于 B 是否完全遮挡 A，使 A 失去全部可见性；且无论哪种场景，都遵循「先暂停 A，再启动 B」的顺序，A.onPause() 必被调用。

为什么不是A.onPause()→ A.onStop()→ B.onCreate()→B.onStart()→B.onResume()？
答：
优先保证新 Activity 快速显示，再处理旧 Activity 的资源释放
先让 A 释放关键前台资源，避免和 B 冲突；
再快速启动 B 并显示给用户，避免黑屏；
最后让 A 安静地释放非必需资源，用户无感知。

自定义 View 绘制过程及各过程作用
答：
自定义 View 的绘制过程是自上而下的三步流程，由系统自动调用，核心过程如下：
onMeasure()：测量过程
作用：确定 View 的宽高尺寸。
系统会传递MeasureSpec（测量规格）给 View，View 根据自身特性和父布局的约束，计算出自身的宽高值，并通过setMeasuredDimension()保存测量结果。
对于 ViewGroup，还需要遍历测量所有子 View 的宽高。
onLayout()：布局过程（仅 ViewGroup 拥有，单一 View 无此方法）
作用：确定子 View 在 ViewGroup 中的位置和大小。
ViewGroup 在自身测量完成后，通过遍历子 View，调用子 View 的layout()方法，为每个子 View 分配具体的坐标（left、top、right、bottom）。
onDraw()：绘制过程
作用：将 View 绘制到屏幕上。
传入Canvas（画布）对象，开发者可通过 Canvas 的 API 绘制图形、文字、图片等内容，完成 View 的最终显示效果。
绘制流程：先绘制背景→绘制自身内容→绘制子 View（ViewGroup）→绘制滑动效果 / 前景。

onMeasure () 和 onLayout () 在 ViewGroup 和子 View 的调用顺序
答：先测量、后布局
测量（onMeasure()）：父方法先执行 → 遍历子 View 执行子测量 → 父基于子结果完成自身测量（自上而下，先父后子）。
布局（onLayout()）：父方法先执行 → 遍历子 View 分配位置 → 父完成布局（自上而下，先父后子）。

onMeasure () 中的 MeasureSpec 类型
答：
MeasureSpec（测量规格）是由32 位 int 值组成的，高 2 位为SpecMode（测量模式），低 30 位为SpecSize（对应模式下的参考尺寸），核心有 3 种类型：
EXACTLY（精确模式）：
对应场景：View 的宽高设置为match_parent，或具体的数值（如100dp）。
特点：父布局已经为 View 确定了精确的尺寸，View 的最终尺寸必须等于SpecSize。
AT_MOST（最大模式）：
对应场景：View 的宽高设置为wrap_content。
特点：父布局为 View 指定了最大尺寸限制，View 的最终尺寸不能超过SpecSize，且需根据自身内容计算合适的尺寸。
UNSPECIFIED（未指定模式）：
对应场景：一般由系统内部使用（如ScrollView的子 View、ListView的 itemView），无明确的尺寸限制。
特点：父布局不对 View 做任何尺寸约束，View 可根据自身需求设置任意尺寸，通常在自定义 View 中无需处理该模式。


动态权限
答：
概念：Android 6.0（API 23）及以上版本引入的权限机制，将权限分为普通权限和危险权限。
普通权限：无需用户授权，在AndroidManifest.xml中声明即可直接使用（如网络权限、蓝牙权限、唤醒权限）。
危险权限：涉及用户隐私或设备安全的权限（如相机、存储、定位、通讯录），不仅需要在AndroidManifest.xml中声明，还需要在运行时（用户使用相关功能时）向用户申请，用户明确授权后才能使用。


Looper死循环为什么不会导致应用卡死？
答：
Looper 死循环是「阻塞等待消息」而非「空循环」，无消息时释放 CPU 资源，几乎不占用系统开销。
应用卡死（ANR）的核心是「主线程被耗时操作阻塞，无法及时处理消息」，与 Looper 死循环无关。
主线程的 Looper 死循环是应用运行的基础，负责处理所有轻量消息，合规使用下不会引发卡死。
子线程的 Looper 死循环与主线程隔离，更不会影响应用的正常运行。
应用卡死（ANR）的触发条件：ANR（Application Not Responding）是安卓系统对应用的「无响应监控」，核心触发场景有 3 种，且都有明确的时间阈值：
主线程：5 秒内未响应用户输入（如点击、滑动）
主线程：10 秒内未完成Activity的生命周期回调（如onCreate()、onResume()）
后台 Service：20 秒内未完成启动或处理任务
简单说：ANR 的本质是「主线程被耗时操作阻塞，无法及时处理用户消息和系统回调」，而非「存在循环」。


RecyclerView滑动的时候整个流程，包括创建Item，复用Item。
答：RecyclerView是一个列表容器，能够复用 Item，和实现列表、网格、瀑布流布局和动画等。
RecyclerView 的使用依赖 3 个核心组件：
Adapter（适配器）：数据和 UI 之间的 “翻译官”，把数据（比如 List<String>）转换成屏幕上能看到的 Item 布局；
LayoutManager（布局管理器）：决定 Item 怎么排列（竖向列表、横向列表、网格）；
ViewHolder（视图持有者）：缓存 Item 的布局控件（比如 TextView、ImageView），避免重复查找控件，提升性能。
流程：滑动列表时，RecyclerView 会先从自身的缓存池中查找是否有可复用的 Item View（已回收的、滑出屏幕的 Item 视图）；如果有，就直接拿到这个 View 对应的 ViewHolder 复用，跳过onCreateViewHolder，直接执行onBindViewHolder绑定新数据；如果缓存池中没有可复用的 View（比如列表刚加载、滑动太快缓存不够），才会调用onCreateViewHolder创建新的 ViewHolder（包含加载 Item 布局、缓存控件），之后再执行onBindViewHolder绑定数据。因为调用onCreateViewHolder的次数远远小于onBindViewHolder。onCreateViewHolder执行一次会加载一个item View，而onBindViewHolder执行一次一般都是赋值等耗时比较少的操作。
notifyDataSetChanged()全局刷新
notifyItemChanged(position)局部刷新

RecyclerView与ListView有哪几层缓存机制？
答:
RecyclerView第一层：Scrap Heap（“即时缓存”“屏幕内缓存”）用途：屏幕内item顺序改变或者屏幕旋转。
第二层：CachedViews（“最近滑出缓存”，缓存的是ViewHolder的 壳，还是需要数据绑定）用途：缓慢上下滑的时候。
第三层ViewCacheExtension（自定义缓存，扩展层）
第四层RecycledViewPool（全局缓存池，最低优先级）存储所有 RecyclerView 共享的 “解绑数据的空 ViewHolder”。用途：多 RecyclerView 共享同类型 Item（切换 Tab 时，第一个 RecyclerView 滑出的 Item 会存入共享的 RecycledViewPool，第二个 RecyclerView 显示时，直接从 Pool 里取 ViewHolder 复用，无需新建。）

findViewById原理是什么？为什么耗时？
答：findViewById 原理：从 ViewTree 的根节点开始，递归遍历所有子 View，通过 int 类型的 id 匹配找到目标控件；
耗时核心原因：布局嵌套越深遍历次数越多，且高频调用（如 RecyclerView 滑动）会放大这种耗时，默认无缓存导致重复遍历；
优化核心思路：通过 ViewHolder/ViewBinding 等方式，将 “遍历查找控件” 的操作从高频场景转移到低频场景，或直接避免遍历。

mainactivity通过intent跳转到secondactivity，然后再seconactivity通过finish()，那么这两个activity的生命周期是如何变化的？
答：// 阶段1：Main→Second
MainActivity.onPause() 
→ SecondActivity.onCreate() 
→ SecondActivity.onStart() 
→ SecondActivity.onResume() 
→ MainActivity.onStop()

// 阶段2：Second.finish()→Main
SecondActivity.onPause() 
→ MainActivity.onRestart() 
→ MainActivity.onStart() 
→ MainActivity.onResume() 
→ SecondActivity.onStop() 
→ SecondActivity.onDestroy()
只有调用finish()或系统回收，Activity 才会被弹出栈，触发onDestroy()。
系统可能在内存不足时，跳过onDestroy()直接杀死 Activity 进程，因此重要的资源释放要在 onPause ()/onStop () 中提前处理（比如保存临时数据、取消请求），onDestroy () 仅作为 “最后兜底”。

activity各个生命周期的最佳实践
生命周期阶段	              核心关键词	                           最佳实践核心
onCreate()	                   初始化、仅 1 次	       控件 / 监听器初始化，异步加载核心数据
onStart()	                   可见、多次	                刷新动态数据，注册可见性监听器
onResume()	          可交互、高频	             启动前台操作，配套 onPause 停止
onPause()	                    失焦、必配套	                暂停前台操作，保存临时输入
onStop()	                   不可见、释放	              注销非前台监听器，保存大量临时数据
onRestart()	           重启、仅返回	                      轻量恢复个性化状态
onDestroy()	            销毁、最后一步	           释放所有资源，避免内存泄漏

为什么用静态内部类来实现ViewHolder？
答：ViewHolder 的核心职责是缓存 Item 控件引用（避免重复 findViewById），不需要访问 Adapter 的非静态成员（比如数据列表、上下文）；
当 Activity 销毁后，缓存池中的 BillViewHolder 持有 Adapter 引用，Adapter 持有 mContext（Activity）引用，导致 Activity 无法被回收，内存泄漏。


RecyclerView 的 ViewHolder 机制是什么？
答：ViewHolder 是 RecyclerView 的核心组件之一，它的作用是缓存视图的引用，减少 findViewById 的调用次数，提高性能。
每个 ViewHolder 对应一个视图，当视图滑动出屏幕时，ViewHolder 会被缓存，以便复用。

 RecyclerView 的数据更新有哪些方法？
答：
当数据集合发生变化时，应该调用 Adapter 的 notifyDataSetChanged、notifyItemInserted、notifyItemRemoved 等方法来通知 RecyclerView。
RecyclerView 会根据这些通知来更新视图。
场景	                               推荐方法	                                       
单个Item 全字段更新	        notifyItemChanged(position)	               
单个Item 部分字段更新	notifyItemChanged(position, payload)	
新增 / 删除单个 Item	         notifyItemInserted/Removed	               
Item 排序 / 移动                 notifyItemMoved	
批量更新连续 Item	notifyItemRangeChanged	
数据源全量替换（小列表）	notifyItemRangeChanged(0, size)
数据源全量替换（大列表）	DiffUtil	
临时应急（不推荐）	notifyDataSetChanged	

Fragment是什么？
答：Activity 是独立的页面容器，Fragment 是依附于 Activity 的子界面模块，不能独立存在；

activity与fragment的区别是什么？
答：
activity是安卓独立的页面容器，拥有完整的生命周期，可单独运行；而fragment是依附于activity的子界面模块，不能独立存在；
fragment的生命周期更复杂，依赖于activity生命周期（Activity 暂停 / 销毁会同步影响 Fragment），还新增了 onAttach（依附）、onCreateView（创建视图）等专属回调。；
activity适用于独立、层次化的页面跳转（如登录页→首页）；Fragment 适用于同一页面内的平级内容切换（如微信底部 Tab），可复用界面模块、适配多屏幕；
Activity 切换有窗口重建开销，跨页面通信成本高；Fragment 共享 Activity 上下文，切换（尤其是 hide/show 方式）更轻量，数据共享和状态保持更简单。

Fragment生命周期有哪些？是如何变化的？
答：
回调方法	                                                               触发时机	                                                                     核心作用
onAttach(Context)	          Fragment 首次依附到所属 Activity 时调用（仅调用一次）	          建立 Fragment 与 Activity 的关联，可获取 Activity 上下文、初始化接口回调
onCreate(Bundle)	          Fragment 被创建时调用（在 onAttach 之后）	                          初始化 Fragment 本身
onCreateView()	                  Fragment 首次创建视图（UI）时调用	                                          加载 Fragment 布局、初始化控件（如 Button、TextView）
onActivityCreated()（已废弃）	          所属 Activity 的 onCreate 方法执行完成后调用	                           可安全访问 Activity 中的控件 / 数据，完成 Fragment 与 Activity 的联动初始化
onViewCreated()  （代替）                 当 Fragment 的视图创建完成后调用                                       视图创建后的初始化
onStart()	                          Fragment 变得可见时（Activity 进入 onStart 时同步触发）	              恢复界面状态（如刷新列表数据）
onResume()	                  Fragment 可与用户交互时（Activity 进入 onResume 时同步触发）	启动动画、注册监听（如广播、传感器）
onPause()	                          Fragment 失去交互能力时（Activity 进入 onPause 时同步触发）	        暂停动画、取消监听，保存临时数据
onStop()	                          Fragment 完全不可见时（Activity 进入 onStop 时同步触发）	        释放非必要资源（如关闭视频播放）
onDestroyView()	          Fragment 的视图被销毁时（如 Fragment 被替换 / 移除）	               清空视图引用（防止内存泄漏，如将控件变量置 null）
onDestroy()	                  Fragment 本身被销毁时（在 onDestroyView 之后）	                        释放所有持有的资源（如关闭数据库连接）
onDetach()	                  Fragment 与 Activity 解除依附关系时（最后一个回调）	                 清空 Activity 引用，彻底解除关联

操作场景	                                                                触发的生命周期回调顺序
启动 Activity（加载 Fragment）	             onAttach → onCreate → onCreateView → onActivityCreated → onStart → onResume
按 Home 键（退到后台）	                       onPause → onStop
从后台返回 App	                                         onStart → onResume
替换 Fragment（如切换到另一个 Fragment）	onPause → onStop → onDestroyView → onDestroy → onDetach
旋转屏幕（Activity 重建）	                        onPause → onStop → onDestroyView → （Activity 重建后）→ onAttach → onCreate → onCreateView → onActivityCreated → onStart → onResume

onCreateView()和onViewCreated区别？
答：https://blog.csdn.net/m0_55939576/article/details/136245509

比如微信的底部Tab为什么使用ViewPager2 + Fragment？为什么不使用多个activity？
答：
维度	                  ViewPager + Fragment 方案	                                     Activity 方案
交互体验	            无缝切换、无动画、无卡顿	                          跳转有动画 / 白屏，体验割裂
性能缓存            Fragment，切换仅复用资源	                          重复创建 / 销毁 Activity，资源消耗大
数据共享	         共享 Activity 上下文，数据同步简单	                  需跨 Activity 通信，逻辑复杂
开发维护	         代码集中，重复逻辑少	                                   重复代码多，维护成本高
状态保持	          Fragment 缓存，切回时保留滚动位置 / 输入状态	    Activity 切回需重新恢复状态（如列表滚动位置）

适合用 Activity 的场景：“独立的、一次性的页面”（比如微信的 “登录页”“朋友圈发布页”“设置页”）—— 这些页面和主界面是 “层级关系”（主界面→登录页），而非 “平级切换关系”；
适合用 Fragment 的场景：“平级的、高频切换的页面”（比如底部 Tab、ViewPager 滑动页面）—— 这些页面共享同一个 “容器”，无需独立窗口。

如何在FragmentA中保存和恢复数据？
答：在FragmentA class中override onSaveInstanceState（）、ViewModel + SavedState、SharedPreferences / 数据库

一个FragmentA切换到另一个FragmentB，其两个的生命周期是如何变化？还有FragmentA旋转屏幕其生命周期如何变化？
答：
方式1：ViewPager2 中滑动切换（微信 Tab 场景，默认缓存）：ViewPager2 默认开启缓存机制（offscreenPageLimit 默认值为 1），即当前页面会缓存左右各 1 个 Fragment，切换时不会销毁，仅改变 “可见 / 可交互状态”。
FragmentA：onPause() → onStop()，如果B首次加载：onAttach→onCreate→onCreateView→onActivityCreated→onStart→onResume,如果B已经有缓存onStart() → onResume()。

方式2：手动替换 Fragment（无缓存，replace 方式）：通过 fragmentManager.beginTransaction().replace(...) 替换 Fragment（非 ViewPager 缓存场景），此时 FragmentA 会被彻底销毁，FragmentB 全新创建：

旋转前（正常显示）：已执行完 onAttach→onCreate→onCreateView→onActivityCreated→onStart→onResume；
旋转中（Activity 销毁）：onPause() → onStop() → onDestroyView() → onDestroy() → onDetach()；
旋转后（Activity 重建）：onAttach() → onCreate() → onCreateView() → onActivityCreated() → onStart() → onResume()。

启动fragment的方式有哪些？
答：Fragment 无 Intent 启动方式，核心通过 FragmentTransaction 的 add()/replace() 动态添加，或布局文件 <fragment> 静态声明。
Fragment 切换依赖 FragmentManager + FragmentTransaction。
获取 FragmentManager → 开启事务 → 执行切换操作 → 提交事务。
获取事务：
FragmentManager fragmentManager = getSupportFragmentManager();
开启事务：
FragmentTransaction transaction = fragmentManager.beginTransaction();
执行切换操作：将 container 中的 Fragment 替换为目标 Fragment
transaction.replace(R.id.fragment_container, targetFragment);R.id.fragment_container是Fragment 容器
提交事务：
transaction.commit();异步
transaction.commitNow(); 同步（慎用）

hide/show :需要先通过 add () 将所有 Fragment 加入容器，再通过 hide/show 切换；
切换后 Fragment 的生命周期：仅执行 onHiddenChanged(boolean hidden) 回调（可在 Fragment 中重写该方法处理隐藏 / 显示逻辑）；

Fragment中add与replace的区别？
答：
### 核心区别总结
1. **操作逻辑**：
   - `add()`：将新 Fragment **添加** 到容器中（容器可同时存在多个 Fragment，仅最后添加的会显示），原有 Fragment 不会被销毁，只是被覆盖；
   - `replace()`：先**移除/销毁**容器中所有已存在的 Fragment，再将新 Fragment 添加到容器，容器始终只有一个 Fragment。
2. **生命周期影响**：
   - `add()`：原有 Fragment 仅视图被覆盖，生命周期无变化（不会执行 `onDestroyView`/`onDestroy`）；新 Fragment 执行完整的创建生命周期（`onAttach→onResume`）；
   - `replace()`：原有 Fragment 会执行完整的销毁生命周期（`onPause→onDetach`）；新 Fragment 执行完整的创建生命周期。
3. **状态与内存**：
   - `add()`：适合需保留原有 Fragment 状态（如输入框内容、列表滚动位置）的场景，但会占用更多内存（多个 Fragment 常驻容器）；
   - `replace()`：内存占用低，但原有 Fragment 状态会丢失，适合无需保留状态的 Fragment 切换。
4. **搭配使用**：
   - `add()` 通常和 `hide()`/`show()` 配合实现“保留状态的切换”；
   - `replace()` 可单独使用，实现“销毁重建式切换”。

### 关键点回顾
1. `add` 是“追加”（多 Fragment 共存），`replace` 是“替换”（先清后加，单 Fragment 存在）；
2. `add` 不销毁旧 Fragment（状态保留、内存占用高），`replace` 销毁旧 Fragment（状态丢失、内存占用低）；
3. 需保留状态用 `add + hide/show`，无需保留状态用 `replace`。

假如现在一个activityA页面有多个fragment。然后现在activityA和fragment都处于onResume（）。现在点击某个按钮跳转到另一个activityB，生命周期如何变化？
答：
核心顺序：ActivityA 先 pause → ActivityB 启动并 resume → ActivityA 再 stop；内部 Fragment 全程跟随 Activity，仅执行 pause/stop；
关键规律：Fragment 生命周期完全依附宿主 Activity，Activity 暂停 / 停止会同步触发所有 Fragment 暂停 / 停止，且无销毁操作；
性能逻辑：系统先完成新 Activity 的显示，再处理旧 Activity 的停止，避免界面卡顿。

如何在Fragment中处理用户交互事件？
答：如果是在fragment处理用户交互事件，直接在 Fragment 的 onViewCreate 中找到控件，绑定点击 / 监听事件，逻辑和 Activity 中一致；
如果是跨组件场景：交互事件需传递给 Activity（核心），则通过接口回调传递事件（解耦、避免内存泄漏，在fragment定义接口，activity实现接口。

activity与fragment是如何进行通信的？
答：
1. 接口回调（Fragment → Activity，最经典、官方推荐）
在 Fragment 内部定义通信接口；
Activity 实现该接口；
Fragment 在 onAttach() 中获取接口实例；
Fragment 触发事件时调用接口方法，Activity 接收并处理。

2. Bundle 传参（Activity → Fragment，最常用）
Activity 向 Fragment 传递初始化数据（如 ID、参数），通过 setArguments() 传递 Bundle，Fragment 在 onCreate() 中获取。
Activity 构建 Bundle，存入参数；
通过 Fragment 的静态工厂方法（推荐）设置 Bundle；
Fragment 从 arguments 中获取参数。

3. ViewModel + LiveData（Activity ↔ Fragment，Jetpack 推荐）
ViewModel 的生命周期与 Activity 绑定，Activity 和其下的所有 Fragment 可获取同一个 ViewModel 实例，通过 LiveData/StateFlow 实现数据监听。

Fragment的requireActivity()和getActivity()方法作用是什么？区别是什么？
答：作用是获取当前 Fragment 所依附的 Activity 实例
特性	requireActivity()	getActivity()
返回值	           非空 Activity 实例（直接用，无需判空）	           可能返回 null（需手动判空）
异常处理	             Activity 不存在时主动抛异常	                         Activity 不存在时返回 null，不抛异常
适用场景	         确定 Activity 一定存在的场景（推荐优先用）	不确定 Activity 是否存在，需容错的场景
代码简洁性           	无需判空，代码更简洁	                                   必须手动判空，否则易空指针

onSaveInstanceState和onSaveInstanceState和onViewStateRestored什么时候调用？
答：页面状态保存 / 恢复
onPause() → onSaveInstanceState() → onStop()
onCreate() → onStart() → onRestoreInstanceState() → onResume()
onCreate() → onCreateView()（重建视图）→ onViewStateRestored(Bundle) → onStart() → onResume()。
onSaveInstanceState()：系统 “可能销毁” Activity 前（屏幕旋转、退后台、内存不足），被动触发，用于备份临时状态；
onRestoreInstanceState()：Activity 被系统销毁后重建时触发，用于恢复之前备份的状态，调用在 onStart() 后、onResume() 前。
只有当 savedInstanceState 不为空时才会调用

onSaveInstanceState什么情况才会保存，哪些情况不会保存？
答：屏幕旋转（横竖屏切换）和系统因内存不足销毁后台 Activity（被动）
用户主动按「返回键」退出 Activity和开发者主动调用 finish() 销毁 Activity（用户主动）

屏幕旋转生命周期变化？
答：
// 销毁阶段
Activity.onPause() → Fragment.onPause()
→ Activity.onSaveInstanceState() → Fragment.onSaveInstanceState()
→ Activity.onStop() → Fragment.onStop()
→ Fragment.onDestroyView() → Fragment.onDestroy() → Fragment.onDetach()
→ Activity.onDestroy()

// 重建阶段
Activity.onCreate()
→ Fragment.onAttach() → Fragment.onCreate()
→ Activity.onStart() → Fragment.onCreateView() → Fragment.onViewCreated() 
→ Fragment.onViewStateRestored() → Fragment.onStart()
→ Activity.onRestoreInstanceState()（可选）
→ Activity.onResume() → Fragment.onResume()
